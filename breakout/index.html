<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breakout Game</title>
    <style>
        body {
            text-align: center;
            font-family: Arial, Helvetica, sans-serif;
            background-color: #f0f0f0;
        }

        canvas {
            border: 1px solid #000;
            background-color: #fff;
            margin-bottom: 20px;
        }

        p {
            margin: 0;
            padding: 0;
        }

        button {
            margin: 20px;
        }
    </style>
</head>

<body>
    <h1>Breakout Game</h1>
    <script>
        const canvas = document.createElement("canvas");
        canvas.width = 480;
        canvas.height = 320;
        document.body.appendChild(canvas);
        const ctx = canvas.getContext("2d");
        const gameState = {
            // id of reququestAnimationFrame
            stopMain: null,
            // keeps track of the last provided requestAnimationFrame timestamp.
            lastRender: 0,
            // keeps track of the last update time. Always increments by tickLength.
            lastTick: 0,
            // is how frequently the game state updates. It is 60 Hz (16ms) here.
            tickLength: 16,
            // timeout after ball is lost (ms)
            timeoutAfterBallLost: 500,
            // number of player lives
            lives: 3,
            // whether the game has started
            gameStarted: false,
            // whether the game is lost
            gameLost: false,
            // game objects and state
            objects: {
                ball: {
                    x: canvas.width / 2,
                    y: canvas.height - 30,
                    radius: 10,
                    dx: 2,
                    dy: -2
                },
                paddle: {
                    width: 75,
                    height: 10,
                    x: (canvas.width - 75) / 2,
                    y: canvas.height - 10, // minus height of paddle
                    keyboardSpeed: 7
                },
                bricks: (function () {
                    const cols = 6;
                    const rows = 2;
                    const gap = 12; // gleicher Abstand links, rechts und zwischen den Bricks
                    const brickWidth = (canvas.width - (cols + 1) * gap) / cols; // ergibt 66 bei canvas.width=480
                    const brickHeight = 20;
                    const startY = 40;
                    const rowGap = gap + brickHeight; // y-Abstand zwischen den Reihen (20 Höhe + 20 Abstand wie vorher)
                    const arr = [];
                    for (let r = 0; r < rows; r++) {
                        for (let c = 0; c < cols; c++) {
                            const x = gap + c * (brickWidth + gap);
                            const y = startY + r * rowGap;
                            arr.push({ width: brickWidth, height: brickHeight, x: x, y: y, status: 1 });
                        }
                    }
                    return arr;
                })()
            },
            controls: {
                rightPressed: false,
                leftPressed: false
            }
        };
        let audioCtx = null;
        (() => {
            function pausedGame() {
                return !gameState.gameStarted || gameState.gameLost;
            }
            function playBeep(frequency = 440, durationMs = 200, type = "sine") {
                if (audioCtx.state !== "running") return; // noch keine User-Interaktion → still

                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();

                osc.type = type;
                osc.frequency.setValueAtTime(frequency, audioCtx.currentTime);

                // Kurze Hüllkurve: Anti-Klick (Attack/Release)
                const now = audioCtx.currentTime;
                const attack = 0.002;
                const release = 0.03;
                const durSec = Math.max(0, durationMs / 1000);

                gain.gain.setValueAtTime(0.0001, now);
                gain.gain.linearRampToValueAtTime(0.12, now + attack); // Lautstärke anpassen
                // während des Tons halten
                gain.gain.setValueAtTime(0.12, now + Math.max(attack, durSec - release));
                // soft release
                gain.gain.exponentialRampToValueAtTime(0.0001, now + durSec);

                osc.connect(gain);
                gain.connect(audioCtx.destination);

                osc.start(now);
                osc.stop(now + durSec);

                osc.onended = () => {
                    osc.disconnect();
                    gain.disconnect();
                };
            }

            function update(tick) {
                if(pausedGame()) {
                    return; // game over
                }
                // ball collision with walls
                if (gameState.objects.ball.x + gameState.objects.ball.dx > canvas.width - gameState.objects.ball.radius || gameState.objects.ball.x + gameState.objects.ball.dx < gameState.objects.ball.radius) {
                    gameState.objects.ball.dx = -gameState.objects.ball.dx;
                    playBeep(440, 100);
                }
                // ball collision with top
                if (gameState.objects.ball.y + gameState.objects.ball.dy < gameState.objects.ball.radius) {
                    gameState.objects.ball.dy = -gameState.objects.ball.dy;
                    playBeep(396, 100);
                }
                // ball falls below paddle
                if (gameState.objects.ball.y > canvas.height + gameState.objects.ball.radius) {
                    if (gameState.timeoutAfterBallLost === 500) {
                        playBeep(297, 200);
                    }
                    gameState.timeoutAfterBallLost -= gameState.tickLength;
                    if (gameState.timeoutAfterBallLost <= 0) {
                        gameState.timeoutAfterBallLost = 500;

                        gameState.lives -= 1;
                        if (gameState.lives <= 0) {
                            gameState.gameLost = true;
                            return;
                        }

                        // reset ball position
                        gameState.objects.ball.x = canvas.width / 2;
                        gameState.objects.ball.y = canvas.height - 30;
                        gameState.objects.ball.dx = 2;
                        gameState.objects.ball.dy = -2;
                    }
                }

                // paddle movement
                if (gameState.controls.rightPressed && gameState.objects.paddle.x < canvas.width - gameState.objects.paddle.width) {
                    gameState.objects.paddle.x += gameState.objects.paddle.keyboardSpeed;
                } else if (gameState.controls.leftPressed && gameState.objects.paddle.x > 0) {
                    gameState.objects.paddle.x -= gameState.objects.paddle.keyboardSpeed;
                }

                // paddle collision
                if (gameState.objects.ball.y + gameState.objects.ball.radius > gameState.objects.paddle.y &&
                    gameState.objects.ball.x > gameState.objects.paddle.x &&
                    gameState.objects.ball.x < gameState.objects.paddle.x + gameState.objects.paddle.width) {
                    gameState.objects.ball.dy = -gameState.objects.ball.dy;
                    gameState.objects.ball.y = gameState.objects.paddle.y - gameState.objects.ball.radius; // prevent sticking
                    playBeep(396, 100);
                }

                // brick collision
                gameState.objects.bricks.forEach((brick) => {
                    if (brick.status === 1) {
                        if (gameState.objects.ball.x > brick.x &&
                            gameState.objects.ball.x < brick.x + brick.width &&
                            gameState.objects.ball.y - gameState.objects.ball.radius < brick.y + brick.height &&
                            gameState.objects.ball.y + gameState.objects.ball.radius > brick.y) {
                            gameState.objects.ball.dy = -gameState.objects.ball.dy;
                            brick.status = 0; // brick is hit
                            playBeep(523, 100);
                        }
                    }
                });

                // update ball position
                gameState.objects.ball.x += gameState.objects.ball.dx;
                gameState.objects.ball.y += gameState.objects.ball.dy;
            }
            function initAudio() {
                // can only be started after trusted user interaction,
                // e.g., click, touch, keypress (only space or enter)
                if (!audioCtx)
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            function startGame() {
                if(!gameState.gameStarted) {
                    initAudio();
                    gameState.gameStarted = true;
                }
            }
            function userInput() {
                document.addEventListener("mousemove", (event) => {
                    if(pausedGame()) return; // no input when paused or game over
                    const relativeX = event.clientX - canvas.offsetLeft;
                    if (relativeX > 0 && relativeX < canvas.width) {
                        gameState.objects.paddle.x = relativeX - gameState.objects.paddle.width / 2;
                    }
                });
                document.addEventListener("touchmove", (event) => {
                    if(pausedGame()) return; // no input when paused or game over
                    const touch = event.touches[0];
                    const relativeX = touch.clientX - canvas.offsetLeft;
                    if (relativeX > 0 && relativeX < canvas.width) {
                        gameState.objects.paddle.x = relativeX - gameState.objects.paddle.width / 2;
                    }
                }, { passive: false });
                document.addEventListener("keydown", (event) => {
                    if(!gameState.gameStarted && event.key === " ") {
                        startGame();
                        return;
                    }
                    if (event.key === "ArrowRight" && !gameState.gameLost) {
                        gameState.controls.rightPressed = true;
                    } else if (event.key === "ArrowLeft" && !gameState.gameLost) {
                        gameState.controls.leftPressed = true;
                    } else if (event.key === "r" && gameState.gameLost) {
                        // Restart the game
                        gameState.gameLost = false;
                        gameState.lives = 3;
                        gameState.objects.ball.x = canvas.width / 2;
                        gameState.objects.ball.y = canvas.height - 30;
                        gameState.objects.ball.dx = 2;
                        gameState.objects.ball.dy = -2;
                        // Reset bricks
                        gameState.objects.bricks.forEach((brick) => {
                            brick.status = 1;
                        });
                    }
                });
                document.addEventListener("keyup", (event) => {
                    if (event.key === "ArrowRight") {
                        gameState.controls.rightPressed = false;
                    } else if (event.key === "ArrowLeft") {
                        gameState.controls.leftPressed = false;
                    }
                });
                document.addEventListener("click", () => {
                    startGame();
                });
            }
            CanvasRenderingContext2D.prototype.fillCircle = function (x, y, r) {
                this.beginPath();
                this.arc(x, y, r, 0, 2 * Math.PI);
                this.fill();
            }
            function render(tFrame) {
                ctx.miterLimit = 2;
                // Clear the canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Render game objects here

                // Draw ball
                ctx.fillStyle = "#0095DD";
                ctx.fillCircle(gameState.objects.ball.x, gameState.objects.ball.y, gameState.objects.ball.radius);

                // Draw paddle
                ctx.fillStyle = "#0095DD";
                ctx.fillRect(gameState.objects.paddle.x, gameState.objects.paddle.y, gameState.objects.paddle.width, gameState.objects.paddle.height);

                // Draw bricks
                gameState.objects.bricks.forEach((brick) => {
                    if (brick.status === 1) {
                        ctx.fillStyle = "#0095DD";
                        ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                    }
                });

                ctx.font = "16px Arial";
                ctx.fillStyle = "#0095DD";
                ctx.fillText("Lives: " + gameState.lives, canvas.width - 80, 20);

                if(gameState.gameLost) {
                    ctx.font = "24px Arial";
                    ctx.fillStyle = "red";
                    ctx.fillText("Game Over!", canvas.width / 2 - 70, canvas.height / 2);
                    ctx.fillText("Refresh or press 'r' to Restart", canvas.width / 2 - 160, canvas.height / 2 + 30);
                }

                if(!gameState.gameStarted) {
                    ctx.fillStyle = "black";
                    ctx.font = "bold 36px Arial";
                    ctx.fillText("BREAKOUT", canvas.width / 2 - 100, canvas.height / 2 - 40);
                    ctx.font = "24px Arial";
                    ctx.fillText("Click, touch or press 'space' to Start", canvas.width / 2 - 190, canvas.height / 2);
                    ctx.font = "16px Arial";
                    ctx.fillText("Use mouse, touch, or arrow keys to move paddle", canvas.width / 2 - 170, canvas.height / 2 + 30);
                }
            }
            function queueUpdates(numTicks) {
                for (let i = 0; i < numTicks; i++) {
                    gameState.lastTick += gameState.tickLength; // Now lastTick is this tick.
                    update(gameState.lastTick);
                }
            }

            function main(tFrame) {
                gameState.stopMain = window.requestAnimationFrame(main);
                const nextTick = gameState.lastTick + gameState.tickLength;
                // numTicks is how many updates should have happened between these two rendered frames.
                let numTicks = 0;
                if (tFrame > nextTick) {
                    const timeSinceTick = tFrame - gameState.lastTick;
                    numTicks = Math.floor(timeSinceTick / gameState.tickLength);
                }

                queueUpdates(numTicks);
                render(tFrame);
                gameState.lastRender = tFrame;
            }

            userInput();
            gameState.lastTick = performance.now();
            gameState.lastRender = gameState.lastTick; // Pretend the first draw was on first update.
            main(performance.now());
        })();
    </script>
</body>

</html>