<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breakout Game</title>
    <style>
        body {
            text-align: center;
            background-color: #f0f0f0;
        }

        canvas {
            border: 1px solid #000;
            background-color: #fff;
            margin-bottom: 20px;
        }

        p {
            margin: 0;
            padding: 0;
        }

        button {
            margin: 20px;
        }
    </style>
</head>

<body>
    <h1>Breakout Game</h1>
    <canvas id="gameCanvas" width="480" height="320"></canvas>
    <div>
        <p>Press "Start Game" to begin!</p>
        <p>Move the paddle with your mouse.</p>
        <button id="startButton">Start Game</button>
    </div>
    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const gameState = {
            // id of reququestAnimationFrame
            stopMain: null,
            // keeps track of the last provided requestAnimationFrame timestamp.
            lastRender: 0,
            // keeps track of the last update time. Always increments by tickLength.
            lastTick: 0,
            // is how frequently the game state updates. It is 60 Hz (16ms) here.
            tickLength: 16,
            // is true when the ball is lost
            ballLost: false,
            // timeout after ball is lost (ms)
            timeoutAfterBallLost: 500,
            // game objects and state
            objects: {
                ball: {
                    x: canvas.width / 2,
                    y: canvas.height - 30,
                    radius: 10,
                    dx: 2,
                    dy: -2
                },
                paddle: {
                    width: 75,
                    height: 10,
                    x: (canvas.width - 75) / 2,
                    y: canvas.height - 10 // minus height of paddle
                },
                bricks: (function () {
                    const cols = 6;
                    const rows = 2;
                    const gap = 12; // gleicher Abstand links, rechts und zwischen den Bricks
                    const brickWidth = (canvas.width - (cols + 1) * gap) / cols; // ergibt 66 bei canvas.width=480
                    const brickHeight = 20;
                    const startY = 40;
                    const rowGap = gap + brickHeight; // y-Abstand zwischen den Reihen (20 Höhe + 20 Abstand wie vorher)
                    const arr = [];
                    for (let r = 0; r < rows; r++) {
                        for (let c = 0; c < cols; c++) {
                            const x = gap + c * (brickWidth + gap);
                            const y = startY + r * rowGap;
                            arr.push({ width: brickWidth, height: brickHeight, x: x, y: y, status: 1 });
                        }
                    }
                    return arr;
                })()
            }
        };
        let audioCtx = null;
        (() => {
            function playBeep(frequency = 440, durationMs = 200, type = "sine") {
                if (audioCtx.state !== "running") return; // noch keine User-Interaktion → still

                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();

                osc.type = type;
                osc.frequency.setValueAtTime(frequency, audioCtx.currentTime);

                // Kurze Hüllkurve: Anti-Klick (Attack/Release)
                const now = audioCtx.currentTime;
                const attack = 0.002;
                const release = 0.03;
                const durSec = Math.max(0, durationMs / 1000);

                gain.gain.setValueAtTime(0.0001, now);
                gain.gain.linearRampToValueAtTime(0.12, now + attack); // Lautstärke anpassen
                // während des Tons halten
                gain.gain.setValueAtTime(0.12, now + Math.max(attack, durSec - release));
                // soft release
                gain.gain.exponentialRampToValueAtTime(0.0001, now + durSec);

                osc.connect(gain);
                gain.connect(audioCtx.destination);

                osc.start(now);
                osc.stop(now + durSec);

                osc.onended = () => {
                    osc.disconnect();
                    gain.disconnect();
                };
            }

            function update(tick) {
                // ball collision with walls
                if (gameState.objects.ball.x + gameState.objects.ball.dx > canvas.width - gameState.objects.ball.radius || gameState.objects.ball.x + gameState.objects.ball.dx < gameState.objects.ball.radius) {
                    gameState.objects.ball.dx = -gameState.objects.ball.dx;
                    playBeep(440, 100);
                }
                // ball collision with top
                if (gameState.objects.ball.y + gameState.objects.ball.dy < gameState.objects.ball.radius) {
                    gameState.objects.ball.dy = -gameState.objects.ball.dy;
                    playBeep(396, 100);
                }
                // ball falls below paddle
                if (gameState.objects.ball.y > canvas.height + gameState.objects.ball.radius) {
                    gameState.ballLost = true;
                    if (gameState.timeoutAfterBallLost === 500) {
                        playBeep(297, 200);
                    }
                    gameState.timeoutAfterBallLost -= gameState.tickLength;
                    if (gameState.timeoutAfterBallLost <= 0) {
                        gameState.ballLost = false;
                        gameState.timeoutAfterBallLost = 500;
                        // reset ball position
                        gameState.objects.ball.x = canvas.width / 2;
                        gameState.objects.ball.y = canvas.height - 30;
                        gameState.objects.ball.dx = 2;
                        gameState.objects.ball.dy = -2;
                    }
                }

                // paddle collision
                if (gameState.objects.ball.y + gameState.objects.ball.radius > gameState.objects.paddle.y &&
                    gameState.objects.ball.x > gameState.objects.paddle.x &&
                    gameState.objects.ball.x < gameState.objects.paddle.x + gameState.objects.paddle.width) {
                    gameState.objects.ball.dy = -gameState.objects.ball.dy;
                    gameState.objects.ball.y = gameState.objects.paddle.y - gameState.objects.ball.radius; // prevent sticking
                    playBeep(396, 100);
                }

                // brick collision
                gameState.objects.bricks.forEach((brick) => {
                    if (brick.status === 1) {
                        if (gameState.objects.ball.x > brick.x &&
                            gameState.objects.ball.x < brick.x + brick.width &&
                            gameState.objects.ball.y - gameState.objects.ball.radius < brick.y + brick.height &&
                            gameState.objects.ball.y + gameState.objects.ball.radius > brick.y) {
                            gameState.objects.ball.dy = -gameState.objects.ball.dy;
                            brick.status = 0; // brick is hit
                            playBeep(523, 100);
                        }
                    }
                });

                // update ball position
                gameState.objects.ball.x += gameState.objects.ball.dx;
                gameState.objects.ball.y += gameState.objects.ball.dy;
            }
            function userInput() {
                document.addEventListener("mousemove", (event) => {
                    const relativeX = event.clientX - canvas.offsetLeft;
                    if (relativeX > 0 && relativeX < canvas.width) {
                        gameState.objects.paddle.x = relativeX - gameState.objects.paddle.width / 2;
                    }
                });
            }
            CanvasRenderingContext2D.prototype.fillCircle = function (x, y, r) {
                this.beginPath();
                this.arc(x, y, r, 0, 2 * Math.PI);
                this.fill();
            }
            function render(tFrame) {
                ctx.miterLimit = 2;
                // Clear the canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Render game objects here

                // Draw ball
                ctx.fillStyle = "#0095DD";
                ctx.fillCircle(gameState.objects.ball.x, gameState.objects.ball.y, gameState.objects.ball.radius);

                // Draw paddle
                ctx.fillStyle = "#0095DD";
                ctx.fillRect(gameState.objects.paddle.x, gameState.objects.paddle.y, gameState.objects.paddle.width, gameState.objects.paddle.height);

                // Draw bricks
                gameState.objects.bricks.forEach((brick) => {
                    if (brick.status === 1) {
                        ctx.fillStyle = "#0095DD";
                        ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                    }
                });

                // If ball is lost, show message
                if (gameState.ballLost) {
                    ctx.font = "16px Arial";
                    ctx.fillStyle = "#ff0000";
                    ctx.fillText("Ball lost! Resetting in " + gameState.timeoutAfterBallLost + "ms", 10, 20);
                }
            }
            function queueUpdates(numTicks) {
                for (let i = 0; i < numTicks; i++) {
                    gameState.lastTick += gameState.tickLength; // Now lastTick is this tick.
                    update(gameState.lastTick);
                }
            }

            function main(tFrame) {
                gameState.stopMain = window.requestAnimationFrame(main);
                const nextTick = gameState.lastTick + gameState.tickLength;
                // numTicks is how many updates should have happened between these two rendered frames.
                let numTicks = 0;
                if (tFrame > nextTick) {
                    const timeSinceTick = tFrame - gameState.lastTick;
                    numTicks = Math.floor(timeSinceTick / gameState.tickLength);
                }

                queueUpdates(numTicks);
                render(tFrame);
                gameState.lastRender = tFrame;
            }
            function startGame() {
                if (!audioCtx)
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                document.getElementById("startButton").disabled = true;
                gameState.lastTick = performance.now();
                gameState.lastRender = gameState.lastTick; // Pretend the first draw was on first update.
                main(performance.now());
            }

            userInput();
            document.getElementById("startButton").addEventListener("click", startGame);
        })();
    </script>
</body>

</html>