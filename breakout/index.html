<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breakout Game</title>
    <style>
        body {
            text-align: center;
            background-color: #f0f0f0;
        }

        canvas {
            border: 1px solid #000;
            background-color: #fff;
        }
    </style>
</head>

<body>
    <h1>Breakout Game</h1>
    <canvas id="gameCanvas" width="480" height="320"></canvas>
    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const gameState = {
            // id of reququestAnimationFrame
            stopMain: null,
            // keeps track of the last provided requestAnimationFrame timestamp.
            lastRender: 0,
            // keeps track of the last update time. Always increments by tickLength.
            lastTick: 0,
            // is how frequently the game state updates. It is 60 Hz (16ms) here.
            tickLength: 16,
            // is true when the ball is lost
            ballLost: false,
            // timeout after ball is lost (ms)
            timeoutAfterBallLost: 500,
            // game objects and state
            objects: {
                ball: {
                    x: canvas.width / 2,
                    y: canvas.height - 30,
                    radius: 10,
                    dx: 2,
                    dy: -2
                },
                paddle: {
                    width: 75,
                    height: 10,
                    x: (canvas.width - 75) / 2,
                    y: canvas.height - 10
                },
            }
        };
        (() => {
            function update(tick) {
                // ball collision with walls
                if(gameState.objects.ball.x + gameState.objects.ball.dx > canvas.width - gameState.objects.ball.radius || gameState.objects.ball.x + gameState.objects.ball.dx < gameState.objects.ball.radius) {
                    gameState.objects.ball.dx = -gameState.objects.ball.dx;
                }
                // ball collision with top
                if(gameState.objects.ball.y + gameState.objects.ball.dy < gameState.objects.ball.radius) {
                    gameState.objects.ball.dy = -gameState.objects.ball.dy;
                }
                // ball falls below paddle
                if(gameState.objects.ball.y > canvas.height + gameState.objects.ball.radius) {
                    gameState.ballLost = true;
                    gameState.timeoutAfterBallLost -= gameState.tickLength;
                    if(gameState.timeoutAfterBallLost <= 0) {
                        gameState.ballLost = false;
                        gameState.timeoutAfterBallLost = 500;
                        // reset ball position
                        gameState.objects.ball.x = canvas.width / 2;
                        gameState.objects.ball.y = canvas.height - 30;
                        gameState.objects.ball.dx = 2;
                        gameState.objects.ball.dy = -2;
                    }
                }

                // paddle collision
                if (gameState.objects.ball.y + gameState.objects.ball.radius > gameState.objects.paddle.y &&
                    gameState.objects.ball.x > gameState.objects.paddle.x &&
                    gameState.objects.ball.x < gameState.objects.paddle.x + gameState.objects.paddle.width) {
                    gameState.objects.ball.dy = -gameState.objects.ball.dy;
                }

                // update ball position
                gameState.objects.ball.x += gameState.objects.ball.dx;
                gameState.objects.ball.y += gameState.objects.ball.dy;
            }
            function userInput() {
                document.addEventListener("mousemove", (event) => {
                    const relativeX = event.clientX - canvas.offsetLeft;
                    if(relativeX > 0 && relativeX < canvas.width) {
                        gameState.objects.paddle.x = relativeX - gameState.objects.paddle.width / 2;
                    }
                });
            }
            CanvasRenderingContext2D.prototype.fillCircle = function (x,y,r) {
                this.beginPath();
                this.arc (x,y,r,0,2*Math.PI);
                this.fill();
            }
            function render(tFrame) {
                ctx.miterLimit = 2;
                // Clear the canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Render game objects here

                // Draw ball
                ctx.fillStyle = "#0095DD";
                ctx.fillCircle(gameState.objects.ball.x, gameState.objects.ball.y, gameState.objects.ball.radius);

                // Draw paddle
                ctx.fillStyle = "#0095DD";
                ctx.fillRect(gameState.objects.paddle.x, gameState.objects.paddle.y, gameState.objects.paddle.width, gameState.objects.paddle.height);

                // If ball is lost, show message
                if(gameState.ballLost) {
                    ctx.font = "16px Arial";
                    ctx.fillStyle = "#ff0000";
                    ctx.fillText("Ball lost! Resetting in " + gameState.timeoutAfterBallLost+ "ms", 10, 20);
                }
            }
            function queueUpdates(numTicks) {
                for (let i = 0; i < numTicks; i++) {
                    gameState.lastTick += gameState.tickLength; // Now lastTick is this tick.
                    update(gameState.lastTick);
                }
            }

            function main(tFrame) {
                gameState.stopMain = window.requestAnimationFrame(main);
                const nextTick = gameState.lastTick + gameState.tickLength;
                // numTicks is how many updates should have happened between these two rendered frames.
                let numTicks = 0;
                if (tFrame > nextTick) {
                    const timeSinceTick = tFrame - gameState.lastTick;
                    numTicks = Math.floor(timeSinceTick / gameState.tickLength);
                }

                queueUpdates(numTicks);
                render(tFrame);
                gameState.lastRender = tFrame;
            }
            gameState.lastTick = performance.now();
            gameState.lastRender = gameState.lastTick; // Pretend the first draw was on first update.

            userInput();
            main(performance.now());
        })();
    </script>
</body>

</html>